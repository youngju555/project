from ultralytics import YOLO
import cv2
import numpy as np
from collections import deque

# -------------------------
# âš™ï¸ ì„¤ì •
# -------------------------
model = YOLO(r"C:\Users\peo00\runs\segment\blue_box_seg_training3\weights\best.pt")  # YOLO ëª¨ë¸ ê²½ë¡œ
cap = cv2.VideoCapture(1)
# ì•ˆì •í™” íŒŒë¼ë¯¸í„°
alpha = 0.2                 # EMA í•„í„° ê°•ë„
angle_buffer = deque(maxlen=10)  # ìµœê·¼ Ní”„ë ˆì„ í‰ê· 
angle_lock_threshold = 0.8  # ê°ë„ ë³€í™” í—ˆìš© í•œê³„
lock_counter = 0
locked_angle = None
smooth_angle = None
last_angle = None

print("ğŸ¯ ì‹¤í–‰ ì¤‘: 'Q'í‚¤ë¡œ ì¢…ë£Œ")

# -------------------------
# âš™ï¸ ê°ë„ ê³„ì‚° í•¨ìˆ˜
# -------------------------
def get_angle_from_roi(frame, x1, y1, x2, y2):
    roi = frame[int(y1):int(y2), int(x1):int(x2)]
    if roi.size == 0:
        return None

    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return None

    c = max(contours, key=cv2.contourArea)
    if cv2.contourArea(c) < 300:
        return None

    rect = cv2.minAreaRect(c)
    ((_, _), (w, h), angle) = rect

    # ë³´ì •
    if angle < -45:
        angle += 90
    if w < h:
        angle = angle
    else:
        angle = angle + 90

    return angle % 90  # 0~180ë„ë¡œ ì œí•œ
    # return angle % 180  # 0~180ë„ë¡œ ì œí•œ


# -------------------------
# âš™ï¸ ë©”ì¸ ë£¨í”„
# -------------------------
while True:
    ret, frame = cap.read()
    if not ret:
        break

    results = model(frame, stream=True)

    for r in results:
        boxes = r.boxes.xyxy.cpu().numpy()
        confs = r.boxes.conf.cpu().numpy()

        if len(boxes) == 0:
            continue

        x1, y1, x2, y2 = boxes[0].astype(int)
        conf = confs[0]
        angle = get_angle_from_roi(frame, x1, y1, x2, y2)

        # ===== ì•ˆì •í™” í•„í„° =====
        if angle is not None:
            angle_buffer.append(angle)
            avg_angle = np.mean(angle_buffer)

            if smooth_angle is None:
                smooth_angle = avg_angle
            else:
                smooth_angle = alpha * avg_angle + (1 - alpha) * smooth_angle

            # LOCK
            if abs(smooth_angle - avg_angle) < angle_lock_threshold:
                lock_counter += 1
                if lock_counter > 10:
                    locked_angle = smooth_angle
            else:
                lock_counter = 0
                locked_angle = None

            last_angle = smooth_angle

        display_angle = locked_angle if locked_angle is not None else (smooth_angle or 0)

        # ===== ì •í™•ë„ ê¸°ë°˜ ë¶„ë¥˜ =====
        classify = "ë¶ˆëŸ‰í’ˆ" if conf < 0.7 else "ì–‘í’ˆ"

        # ===== ì‹œê°í™” =====
        color = (0, 0, 255) if classify == "ë¶ˆëŸ‰í’ˆ" else (0, 255, 0)
        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
        cv2.putText(frame, f"Conf: {conf:.2f}", (x1, y1 - 15),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
        cv2.putText(frame, f"Angle: {display_angle:.2f}Â°", (x1, y2 + 25),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
        cv2.putText(frame, classify, (x1, y2 + 50),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

    cv2.imshow("YOLO + OpenCV Angle Test (Yellow Removed)", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
